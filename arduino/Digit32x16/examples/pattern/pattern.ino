// modified by ikkei for Digit 32x16 dot matrix LED 2013.06.29

/*
 Basic LoL Shield Test
 
 Writen for the LoL Shield, designed by Jimmie Rodgers:
 http://jimmieprodgers.com/kits/lolshield/
 
 This needs the Charlieplexing library, which you can get at the
 LoL Shield project page: http://code.google.com/p/lolshield/
 
 Created by Jimmie Rodgers on 12/30/2009.
 Adapted from: http://www.arduino.cc/playground/Code/BitMath
 
 History:
  	December 30, 2009 - V1.0 first version written at 26C3/Berlin
        December 16, 2010 - modified by ikkei for ikkeiplexing shield

  This is free software; you can redistribute it and/or
  modify it under the terms of the GNU Version 3 General Public
  License as published by the Free Software Foundation; 
  or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/
#include <MsTimer2.h>
#include <avr/pgmspace.h>  //AVR library for writing to ROM
#include <Digit32x16.h> //Imports the library, which needs to be
                           //Initialized in setup.

/*
The BitMap array is what contains the frame data. Each line is one full frame.
Since each number is 16 bits, we can easily fit all 16 LEDs per row into it.
The number is calculated by adding up all the bits, starting with lowest on
the left of each row. TERMINATER was chosen as the kill number, so make sure that
is at the end of the matrix, or the program will continue to read into memory.

Here PROGMEM is called, which stores the array into ROM, which leaves us
with our RAM. You cannot change the array during run-time, only when you
upload to the Arduino. You will need to pull it out of ROM, which is covered
below. If you want it to stay in RAM, just delete PROGMEM
*/

// data ID
#define PATT 0 // pattern data
#define TIME 1 // interval time
#define TERM 2 // terminator

const uint16_t BitMap[][9] PROGMEM = {
{TIME,400,0,0,0,0,0,0,0},
{PATT,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000},
{PATT,0x0000,0x0001,0x0001,0x0001,0x0001,0x0000,0x0000,0x0000},
{PATT,0x0000,0x0000,0x0000,0x0001,0x0003,0x0002,0x0002,0x0000},
{PATT,0x0001,0x0004,0x0005,0x0007,0x0007,0x0003,0x0001,0x0002},
{PATT,0x0002,0x0001,0x0003,0x0006,0x000F,0x000B,0x000A,0x0001},
{PATT,0x0004,0x0012,0x0017,0x001D,0x001F,0x000F,0x0004,0x0008},
{PATT,0x0008,0x0004,0x000F,0x001B,0x003F,0x002F,0x0028,0x0006},
{PATT,0x0010,0x0049,0x005F,0x0076,0x007F,0x003F,0x0010,0x0020},
{PATT,0x0020,0x0011,0x003F,0x006E,0x00FF,0x00BF,0x00A0,0x001B},
{PATT,0x0041,0x0122,0x017F,0x01DD,0x01FF,0x00FF,0x0042,0x0081},
{PATT,0x0082,0x0044,0x00FE,0x01BB,0x03FF,0x02FE,0x0282,0x006C},
{PATT,0x0104,0x0489,0x05FD,0x0777,0x07FF,0x03FE,0x0104,0x0202},
{PATT,0x0208,0x0110,0x03F8,0x06EC,0x0FFE,0x0BFA,0x0A0A,0x01B0},
{PATT,0x0410,0x1224,0x17F4,0x1DDC,0x1FFC,0x0FF8,0x0410,0x0808},
{PATT,0x0820,0x0440,0x0FE0,0x1BB0,0x3FF8,0x2FE8,0x2828,0x06C0},
{PATT,0x1040,0x4890,0x5FD0,0x7770,0x7FF0,0x3FE0,0x1040,0x2020},
{PATT,0x2080,0x1100,0x3F80,0x6EC0,0xFFE0,0xBFA0,0xA0A0,0x1B00},
{PATT,0x1040,0x4890,0x5FD0,0x7770,0x7FF0,0x3FE0,0x1040,0x2020},
{PATT,0x0820,0x0440,0x0FE0,0x1BB0,0x3FF8,0x2FE8,0x2828,0x06C0},
{PATT,0x0410,0x1224,0x17F4,0x1DDC,0x1FFC,0x0FF8,0x0410,0x0808},
{PATT,0x0208,0x0110,0x03F8,0x06EC,0x0FFE,0x0BFA,0x0A0A,0x01B0},
{PATT,0x0104,0x0489,0x05FD,0x0777,0x07FF,0x03FE,0x0104,0x0202},
{PATT,0x0082,0x0044,0x00FE,0x01BB,0x03FF,0x02FE,0x0282,0x006C},
{PATT,0x0041,0x0122,0x017F,0x01DD,0x01FF,0x00FF,0x0041,0x0080},
{PATT,0x0020,0x0011,0x003F,0x006E,0x00FF,0x00BF,0x00A0,0x001B},
{PATT,0x0010,0x0048,0x005F,0x0077,0x007F,0x003F,0x0010,0x0020},
{PATT,0x0008,0x0004,0x000F,0x001B,0x003F,0x002F,0x0028,0x0006},
{PATT,0x0004,0x0012,0x0017,0x001D,0x001F,0x000F,0x0004,0x0008},
{PATT,0x0002,0x0001,0x0003,0x0006,0x000F,0x000B,0x000A,0x0001},
{PATT,0x0001,0x0004,0x0005,0x0007,0x0007,0x0003,0x0001,0x0002},
{PATT,0x0000,0x0000,0x0000,0x0001,0x0003,0x0002,0x0002,0x0000},
{PATT,0x0000,0x0001,0x0001,0x0001,0x0001,0x0000,0x0000,0x0000},
{PATT,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000},
{PATT,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000},
{TIME,70,0,0,0,0,0,0,0},
{PATT,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000},
{PATT,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000},
{PATT,0x0000,0x0000,0x0000,0x0001,0x0003,0x0000,0x0000,0x0000},
{PATT,0x0000,0x0001,0x0003,0x0006,0x000F,0x0003,0x0001,0x0000},
{PATT,0x0001,0x0007,0x000F,0x001B,0x003F,0x000E,0x0004,0x0000},
{PATT,0x0007,0x001F,0x003F,0x006D,0x00FF,0x0039,0x0010,0x0000},
{PATT,0x001F,0x007F,0x00FF,0x01B6,0x03FF,0x00E6,0x0040,0x0000},
{PATT,0x007E,0x01FF,0x03FF,0x06DB,0x0FFF,0x0399,0x0100,0x0000},
{PATT,0x01F8,0x07FE,0x0FFF,0x1B6D,0x3FFF,0x0E67,0x0402,0x0000},
{PATT,0x07E0,0x1FF8,0x3FFC,0x6DB6,0xFFFF,0x399C,0x1008,0x0000},
{PATT,0x1F80,0x7FE0,0xFFF0,0xB6D8,0xFFFC,0xE670,0x4020,0x0000},
{PATT,0x7E00,0xFF80,0xFFC0,0xDB60,0xFFF0,0x99C0,0x0080,0x0000},
{PATT,0xF800,0xFE00,0xFF00,0x6D80,0xFFC0,0x6700,0x0200,0x0000},
{PATT,0xE000,0xF800,0xFC00,0xB600,0xFF00,0x9C00,0x0800,0x0000},
{PATT,0x8000,0xE000,0xF000,0xD800,0xFC00,0x7000,0x2000,0x0000},
{PATT,0x0000,0x8000,0xC000,0x6000,0xF000,0xC000,0x8000,0x0000},
{PATT,0x0000,0x0000,0x0000,0x8000,0xC000,0x0000,0x0000,0x0000},
{PATT,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000},
{PATT,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000},
{TERM,0,0,0,0,0,0,0,0},
};



void DisplayBitMap()
{
  int blinkdelay = 100; //Sets the time each frame is shown
  byte frame = 0;
  byte com;

  //while(run == true) {
  do{
    com = pgm_read_word_near (&BitMap[frame][0]);
    if (com == PATT){
      for(byte line = 1; line < 9; line++) {
        uint16_t data = pgm_read_word_near (&BitMap[frame][line]);
        for (byte led=0; led<16; ++led) {
          if (data & (1<<led)) {
            Digit32x16::Set(led, line-1, 1);
          } else {
            Digit32x16::Set(led, line-1, 0);
          }
        }
      }
      delay(blinkdelay);
    } else if (com == TIME){
      blinkdelay = pgm_read_word_near (&BitMap[frame][1]);
    }
    frame++;
  } while (com != TERM);
}

void setup() {
  Digit32x16::Init();  //Initializes the screen
}

void loop() {
  DisplayBitMap();  //Displays the bitmap
}

